name: Reusable App Service Slot Deploy

on:
  workflow_call:
    inputs:
      environment:
        description: Environment name (dev/uat/preprod/prod)
        required: true
        type: string
      resource-group:
        description: Azure Resource Group
        required: true
        type: string
      app-name:
        description: App Service name
        required: true
        type: string
      package:
        description: Path to package (zip)
        required: false
        default: ''
        type: string
      artifact-name:
        description: Name of artifact (if provided, will download the zip from previous job)
        required: false
        type: string
      warmup-url-staging:
        description: URL to warm up staging
        required: false
        type: string
      warmup-url-prod:
        description: URL to warm up production
        required: false
        type: string
      run-from-package:
        description: "'true' to set WEBSITE_RUN_FROM_PACKAGE=1 before deploy (faster, mount zip)"
        required: false
        default: 'false'
        type: string
      expect-version:
        description: Optional version string to verify post-warm-up (fails if mismatch)
        required: false
        default: ''
        type: string
      version-url:
        description: Optional URL that returns version text/JSON; if empty and warmup-url-prod ends with /healthz, wrapper will attempt /_meta
        required: false
        default: ''
        type: string
      use-slot:
        description: "'true' to use staging slot; 'false' for direct prod; 'auto' to detect from plan"
        required: false
        default: 'auto'
        type: string
      skip-swap:
        description: "'true' to skip slot swap (run tests first)"
        required: false
        default: 'false'
        type: string
      skip-deploy:
        description: "'true' to skip the package deploy and only run warm-up/swap"
        required: false
        default: 'false'
        type: string
      display-name:
        description: Optional friendly job name shown in the caller's UI
        required: false
        default: ''
        type: string
    secrets:
      AZURE_CLIENT_ID:
        required: false
      AZURE_TENANT_ID:
        required: false
      AZURE_SUBSCRIPTION_ID:
        required: false
      AZURE_CREDENTIALS:
        required: false

    outputs:
      use_slot:
        description: Resolved use-slot value ('true' or 'false')
        value: ${{ jobs.deploy.outputs.use_slot }}

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    name: ${{ (inputs['display-name'] != '' && inputs['display-name']) || 'Deploy' }}
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    outputs:
      use_slot: ${{ steps.resolve.outputs.use_slot }}
    steps:
      - uses: actions/checkout@v4

      - name: Azure login (smart)
        uses: aexionsolutions/azure-devops-workflows/.github/actions/azure-login-smart@v3.1.3
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Download artifact (if provided)
        if: inputs['artifact-name'] != ''
        uses: actions/download-artifact@v6
        with:
          name: ${{ inputs['artifact-name'] }}
          path: _pkg

      - name: Debug downloaded artifact
        if: inputs['artifact-name'] != ''
        shell: bash
        run: |
          echo "Contents of _pkg after download:"
          ls -lah _pkg/ || true
          find _pkg -type f -name "*.zip" -exec file {} \; || true
          find _pkg -type f -name "*.zip" -exec ls -lh {} \; || true

      - name: Resolve Resource Group (fallback if not provided)
        id: rgres
        if: inputs['resource-group'] == ''
        uses: aexionsolutions/azure-devops-workflows/.github/actions/resolve-rg@v3.1.3
        with:
          environment: ${{ inputs['environment'] }}
          default: ${{ secrets.AZURE_RESOURCE_GROUP }}
          dev: ${{ secrets.AZURE_RG_DEV }}
          uat: ${{ secrets.AZURE_RG_UAT }}
          preprod: ${{ secrets.AZURE_RG_PREPROD }}
          prod: ${{ secrets.AZURE_RG_PROD }}
          verify-exists: 'true'
          fail-on-missing: 'true'

      - name: Resolve package path and slot support
        id: resolve
        shell: bash
        env:
          PKG_INPUT: ${{ inputs['package'] }}
          ARTIFACT_NAME: ${{ inputs['artifact-name'] }}
          USE_SLOT_INPUT: ${{ inputs['use-slot'] }}
          RFP_IN: ${{ inputs['run-from-package'] }}
          RG_INPUT: ${{ inputs['resource-group'] }}
          RG_FALLBACK: ${{ steps.rgres.outputs.resource-group }}
          APP: ${{ inputs['app-name'] }}
          ENVIRONMENT: ${{ inputs['environment'] }}
        run: |
          set -euo pipefail
          RG="${RG_INPUT:-}"
          if [ -z "$RG" ]; then RG="${RG_FALLBACK:-}"; fi
          # Guard required inputs
          if [ -z "${RG:-}" ]; then
            echo "Missing input: resource-group and fallback resolution failed. Ensure a valid Resource Group is available." >&2
            exit 1
          fi
          if [ -z "${APP:-}" ]; then
            echo "Missing input: app-name. Ensure the caller passes 'app-name' to the reusable workflow." >&2
            exit 1
          fi
          ART="$ARTIFACT_NAME"
          if [ -n "$ART" ]; then
            # Find the first zip in the downloaded artifact folder
            PKG=$(find _pkg -maxdepth 1 -type f -name "*.zip" | head -n1 || true)
            if [ -z "$PKG" ]; then
              echo "Artifact $ART did not contain a .zip file" >&2; exit 1
            fi
          else
            PKG="$PKG_INPUT"
          fi
          if [ -z "$PKG" ]; then
            echo "No package provided (inputs.package) and no artifact-name specified; one is required." >&2
            exit 1
          fi
          echo "package=$PKG" >> $GITHUB_OUTPUT

          USE="$USE_SLOT_INPUT"
          if [ "$USE" = "auto" ]; then
            PLAN_ID=$(az webapp show -g "$RG" -n "$APP" --query serverFarmId -o tsv 2>/dev/null || true)
            if [ -z "$PLAN_ID" ]; then
              echo "Could not determine App Service Plan for $APP in RG $RG; defaulting to no slot (use-slot=false)." >&2
              USE=false
            else
              TIER=$(az appservice plan show --ids "$PLAN_ID" --query sku.tier -o tsv 2>/dev/null || true)
              if [ -z "$TIER" ]; then
                echo "Could not read plan SKU tier; defaulting to no slot (use-slot=false)." >&2
                USE=false
              else
                case "$TIER" in
                  Standard|Premium|PremiumV2|PremiumV3|Isolated|IsolatedV2) USE=true;;
                  *) USE=false;;
                esac
              fi
            fi
          fi
          echo "use_slot=$USE" >> $GITHUB_OUTPUT
          # Normalize run-from-package to true/false
          RFP=$(echo "${RFP_IN:-false}" | tr '[:upper:]' '[:lower:]')
          case "$RFP" in
            true|false) : ;;
            *) RFP=false ;;
          esac
          echo "run_from_package=$RFP" >> $GITHUB_OUTPUT

          echo "rg=$RG" >> $GITHUB_OUTPUT

      - name: Configure WEBSITE_RUN_FROM_PACKAGE
        shell: bash
        env:
          RG: ${{ steps.resolve.outputs.rg }}
          APP: ${{ inputs['app-name'] }}
          USE: ${{ steps.resolve.outputs.use_slot }}
          RFP: ${{ steps.resolve.outputs.run_from_package }}
        run: |
          set -euo pipefail
          if [ "$RFP" = "true" ]; then
            if [ "$USE" = "true" ]; then
              az webapp config appsettings set -g "$RG" -n "$APP" --slot staging --settings WEBSITE_RUN_FROM_PACKAGE=1
            else
              az webapp config appsettings set -g "$RG" -n "$APP" --settings WEBSITE_RUN_FROM_PACKAGE=1
            fi
          else
            # Ensure it's removed when not requested
            if [ "$USE" = "true" ]; then
              az webapp config appsettings delete -g "$RG" -n "$APP" --slot staging --setting-names WEBSITE_RUN_FROM_PACKAGE || true
            else
              az webapp config appsettings delete -g "$RG" -n "$APP" --setting-names WEBSITE_RUN_FROM_PACKAGE || true
            fi
          fi

      - name: Set BUILD_VERSION app setting
        if: inputs['expect-version'] != ''
        shell: bash
        env:
          RG: ${{ steps.resolve.outputs.rg }}
          APP: ${{ inputs['app-name'] }}
          VERSION: ${{ inputs['expect-version'] }}
          ENV: ${{ inputs['environment'] }}
          USE: ${{ steps.resolve.outputs.use_slot }}
        run: |
          set -euo pipefail
          echo "Setting BUILD_VERSION=$VERSION on $APP..."
          # Set on both production and staging (staging if using slots)
          if [ "$USE" = "true" ]; then
            # Set on staging slot first (where deployment happens)
            az webapp config appsettings set -g "$RG" -n "$APP" --slot staging \
              --settings BUILD_VERSION="$VERSION" ENV="$ENV"
            # Also set on production (will match after swap)
            az webapp config appsettings set -g "$RG" -n "$APP" \
              --settings BUILD_VERSION="$VERSION" ENV="$ENV"
          else
            # Direct production deployment
            az webapp config appsettings set -g "$RG" -n "$APP" \
              --settings BUILD_VERSION="$VERSION" ENV="$ENV"
          fi

      - name: Deploy via composite
        uses: aexionsolutions/azure-devops-workflows/.github/actions/appservice-slot-deploy@v3.1.3
        with:
          resource-group: ${{ steps.resolve.outputs.rg }}
          app-name: ${{ inputs['app-name'] }}
          package: ${{ steps.resolve.outputs.package }}
          use-slot: ${{ steps.resolve.outputs.use_slot }}
          warmup-url-staging: ${{ inputs['warmup-url-staging'] }}
          warmup-url-prod: ${{ inputs['warmup-url-prod'] }}
          skip-swap: ${{ inputs['skip-swap'] }}
          skip-deploy: ${{ inputs['skip-deploy'] }}
          expect-version: ${{ inputs['expect-version'] }}
          version-url: ${{ inputs['version-url'] }}
