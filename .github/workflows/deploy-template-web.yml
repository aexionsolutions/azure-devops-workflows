name: Template - Deploy Web (App Service)

on:
  workflow_call:
    inputs:
      shared_ref:
        description: 'Ref (tag/sha/branch) of aexionsolutions/azure-devops-workflows to checkout into ./shared. Set this to the same @ref used in the calling repo. If omitted, defaults to main.'
        required: false
        type: string
        default: ''
      environment:
        required: true
        type: string
      app-name:
        required: true
        type: string
      resource-group:
        required: false
        type: string
        default: ''
      artifact-name:
        required: false
        type: string
        default: ''
      package:
        required: false
        type: string
        default: ''
      warmup-url-staging:
        required: false
        type: string
        default: ''
      warmup-url-prod:
        required: false
        type: string
        default: ''
      expect-version:
        required: false
        type: string
        default: ''
      version-url:
        required: false
        type: string
        default: ''
      run-from-package:
        required: false
        type: string
        default: 'true'
      verify-base-url:
        required: false
        type: string
        default: ''
      require-preprod-parity:
        required: false
        type: string
        default: 'false'
      preprod-version-url:
        required: false
        type: string
        default: ''
    secrets:
      AZURE_CLIENT_ID:
        required: false
      AZURE_TENANT_ID:
        required: false
      AZURE_SUBSCRIPTION_ID:
        required: false
      AZURE_CREDENTIALS:
        required: false
      B2C_TEST_USER_EMAIL:
        required: false
      B2C_TEST_USER_PASSWORD:
        required: false

permissions:
  id-token: write
  contents: read

jobs:
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    env:
      CALLER_WORKDIR: caller
    outputs:
      use_slot: ${{ steps.resolve.outputs.use_slot }}
    steps:
      - name: Resolve shared workflows ref
        id: wfref
        shell: bash
        working-directory: .
        run: |
          set -euo pipefail
          INPUT_REF="${{ inputs.shared_ref }}"
          if [ -n "$INPUT_REF" ]; then
            REF="$INPUT_REF"
          else
            REF="main"
            echo "### ⚠️ shared_ref not provided" >> "$GITHUB_STEP_SUMMARY"
            echo "Defaulting shared checkout to 'main'. For version-locked runs, pass inputs.shared_ref matching the @ref used in the caller." >> "$GITHUB_STEP_SUMMARY"
          fi
          echo "ref=$REF" >> "$GITHUB_OUTPUT"
          echo "Resolved shared workflows ref: $REF"

      - name: Checkout caller repo (no token persisted)
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          persist-credentials: false
          path: caller

      - name: Checkout shared workflows repo (no token persisted)
        uses: actions/checkout@v4
        with:
          repository: aexionsolutions/azure-devops-workflows
          ref: ${{ steps.wfref.outputs.ref }}
          fetch-depth: 1
          persist-credentials: false
          path: shared

      - name: Azure login (smart)
        uses: ./shared/.github/actions/azure-login-smart
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Download artifact (if provided)
        if: inputs['artifact-name'] != ''
        uses: actions/download-artifact@v6
        with:
          name: ${{ inputs['artifact-name'] }}
          path: _pkg

      - name: Debug downloaded artifact
        if: inputs['artifact-name'] != ''
        shell: bash
        run: |
          echo "Contents of _pkg after download:"
          ls -lah _pkg/ || true
          find _pkg -type f -name "*.zip" -exec file {} \; || true
          find _pkg -type f -name "*.zip" -exec ls -lh {} \; || true

      - name: Resolve Resource Group (fallback if not provided)
        id: rgres
        if: inputs['resource-group'] == ''
        uses: ./shared/.github/actions/resolve-rg
        with:
          environment: ${{ inputs['environment'] }}
          default: ${{ secrets.AZURE_RESOURCE_GROUP }}
          dev: ${{ secrets.AZURE_RG_DEV }}
          uat: ${{ secrets.AZURE_RG_UAT }}
          preprod: ${{ secrets.AZURE_RG_PREPROD }}
          prod: ${{ secrets.AZURE_RG_PROD }}
          verify-exists: 'true'
          fail-on-missing: 'true'

      - name: Resolve package path and slot support
        id: resolve
        shell: bash
        env:
          PKG_INPUT: ${{ inputs['package'] }}
          ARTIFACT_NAME: ${{ inputs['artifact-name'] }}
          USE_SLOT_INPUT: auto
          RFP_IN: ${{ inputs['run-from-package'] }}
          RG_INPUT: ${{ inputs['resource-group'] }}
          RG_FALLBACK: ${{ steps.rgres.outputs.resource-group }}
          APP: ${{ inputs['app-name'] }}
          ENVIRONMENT: ${{ inputs['environment'] }}
        run: |
          set -euo pipefail
          RG="${RG_INPUT:-}"
          if [ -z "$RG" ]; then RG="${RG_FALLBACK:-}"; fi
          if [ -z "${RG:-}" ]; then
            echo "Missing input: resource-group and fallback resolution failed. Ensure a valid Resource Group is available." >&2
            exit 1
          fi
          if [ -z "${APP:-}" ]; then
            echo "Missing input: app-name. Ensure the caller passes 'app-name' to the reusable workflow." >&2
            exit 1
          fi
          ART="$ARTIFACT_NAME"
          if [ -n "$ART" ]; then
            PKG=$(find _pkg -maxdepth 1 -type f -name "*.zip" | head -n1 || true)
            if [ -z "$PKG" ]; then
              echo "Artifact $ART did not contain a .zip file" >&2; exit 1
            fi
          else
            PKG="$PKG_INPUT"
          fi
          if [ -z "$PKG" ]; then
            echo "No package provided (inputs.package) and no artifact-name specified; one is required." >&2
            exit 1
          fi
          echo "package=$PKG" >> $GITHUB_OUTPUT

          USE="$USE_SLOT_INPUT"
          if [ "$USE" = "auto" ]; then
            PLAN_ID=$(az webapp show -g "$RG" -n "$APP" --query serverFarmId -o tsv 2>/dev/null || true)
            if [ -z "$PLAN_ID" ]; then
              echo "Could not determine App Service Plan for $APP in RG $RG; defaulting to no slot (use-slot=false)." >&2
              USE=false
            else
              TIER=$(az appservice plan show --ids "$PLAN_ID" --query sku.tier -o tsv 2>/dev/null || true)
              if [ -z "$TIER" ]; then
                echo "Could not read plan SKU tier; defaulting to no slot (use-slot=false)." >&2
                USE=false
              else
                case "$TIER" in
                  Standard|Premium|PremiumV2|PremiumV3|Isolated|IsolatedV2) USE=true;;
                  *) USE=false;;
                esac
              fi
            fi
          fi
          echo "use_slot=$USE" >> $GITHUB_OUTPUT

          RFP=$(echo "${RFP_IN:-false}" | tr '[:upper:]' '[:lower:]')
          case "$RFP" in
            true|false) : ;;
            *) RFP=false ;;
          esac
          echo "run_from_package=$RFP" >> $GITHUB_OUTPUT
          echo "rg=$RG" >> $GITHUB_OUTPUT

      - name: Configure WEBSITE_RUN_FROM_PACKAGE
        shell: bash
        env:
          RG: ${{ steps.resolve.outputs.rg }}
          APP: ${{ inputs['app-name'] }}
          USE: ${{ steps.resolve.outputs.use_slot }}
          RFP: ${{ steps.resolve.outputs.run_from_package }}
        run: |
          set -euo pipefail
          if [ "$RFP" = "true" ]; then
            if [ "$USE" = "true" ]; then
              az webapp config appsettings set -g "$RG" -n "$APP" --slot staging --settings WEBSITE_RUN_FROM_PACKAGE=1
            else
              az webapp config appsettings set -g "$RG" -n "$APP" --settings WEBSITE_RUN_FROM_PACKAGE=1
            fi
          else
            if [ "$USE" = "true" ]; then
              az webapp config appsettings delete -g "$RG" -n "$APP" --slot staging --setting-names WEBSITE_RUN_FROM_PACKAGE || true
            else
              az webapp config appsettings delete -g "$RG" -n "$APP" --setting-names WEBSITE_RUN_FROM_PACKAGE || true
            fi
          fi

      - name: Set BUILD_VERSION app setting
        if: inputs['expect-version'] != ''
        shell: bash
        env:
          RG: ${{ steps.resolve.outputs.rg }}
          APP: ${{ inputs['app-name'] }}
          VERSION: ${{ inputs['expect-version'] }}
          ENV: ${{ inputs['environment'] }}
          USE: ${{ steps.resolve.outputs.use_slot }}
        run: |
          set -euo pipefail
          echo "Setting BUILD_VERSION=$VERSION on $APP..."
          if [ "$USE" = "true" ]; then
            az webapp config appsettings set -g "$RG" -n "$APP" --slot staging --settings BUILD_VERSION="$VERSION" ENV="$ENV"
            az webapp config appsettings set -g "$RG" -n "$APP" --settings BUILD_VERSION="$VERSION" ENV="$ENV"
          else
            az webapp config appsettings set -g "$RG" -n "$APP" --settings BUILD_VERSION="$VERSION" ENV="$ENV"
          fi

      - name: Deploy via composite
        uses: ./shared/.github/actions/appservice-slot-deploy
        with:
          resource-group: ${{ steps.resolve.outputs.rg }}
          app-name: ${{ inputs['app-name'] }}
          package: ${{ steps.resolve.outputs.package }}
          use-slot: ${{ steps.resolve.outputs.use_slot }}
          warmup-url-staging: ${{ inputs['warmup-url-staging'] }}
          warmup-url-prod: ${{ inputs['warmup-url-prod'] }}
          skip-swap: 'true'
          expect-version: ${{ inputs['expect-version'] }}
          version-url: ${{ inputs['version-url'] }}

  parity-gate:
    name: Preprod parity gate
    runs-on: ubuntu-latest
    if: inputs.environment == 'prod' && inputs['require-preprod-parity'] == 'true'
    steps:
      - name: Check preprod version matches expected
        shell: bash
        env:
          EXPECT: ${{ inputs['expect-version'] }}
          URL: ${{ inputs['preprod-version-url'] }}
        run: |
          set -euo pipefail
          if [ -z "${EXPECT:-}" ] || [ -z "${URL:-}" ]; then
            echo "Parity gate misconfigured: expect-version or preprod-version-url missing" >&2
            exit 1
          fi
          echo "Checking $URL contains version $EXPECT"
          BODY=$(curl -fsSL --max-time 20 "$URL" || true)
          if ! echo "$BODY" | grep -q "$EXPECT"; then
            echo "Preprod parity check failed: expected $EXPECT not found in response" >&2
            exit 1
          fi

  verify-web:
    name: Verify Web Deployment
    needs: deploy-staging
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    env:
      CALLER_WORKDIR: caller

    defaults:
      run:
        working-directory: caller
    outputs:
      base_url: ${{ steps.base.outputs.url }}
    steps:
      - name: Resolve shared workflows ref
        id: wfref
        shell: bash
        working-directory: .
        run: |
          set -euo pipefail
          INPUT_REF="${{ inputs.shared_ref }}"
          if [ -n "$INPUT_REF" ]; then
            REF="$INPUT_REF"
          else
            REF="main"
            echo "### ⚠️ shared_ref not provided" >> "$GITHUB_STEP_SUMMARY"
            echo "Defaulting shared checkout to 'main'. For version-locked runs, pass inputs.shared_ref matching the @ref used in the caller." >> "$GITHUB_STEP_SUMMARY"
          fi
          echo "ref=$REF" >> "$GITHUB_OUTPUT"
          echo "Resolved shared workflows ref: $REF"

      - name: Checkout caller repo (no token persisted)
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          persist-credentials: false
          path: caller

      - name: Checkout shared workflows repo (no token persisted)
        uses: actions/checkout@v4
        with:
          repository: aexionsolutions/azure-devops-workflows
          ref: ${{ steps.wfref.outputs.ref }}
          fetch-depth: 1
          persist-credentials: false
          path: shared

      - name: Decide base URL
        id: base
        shell: bash
        env:
          ENV: ${{ inputs.environment }}
          PROVIDED: ${{ inputs['verify-base-url'] }}
          USE_SLOT: ${{ needs.deploy-staging.outputs.use_slot }}
        run: |
          if [ -n "$PROVIDED" ]; then echo "url=$PROVIDED" >> $GITHUB_OUTPUT; exit 0; fi
          if [ "$USE_SLOT" = "true" ]; then
            echo "url=https://tems-${ENV}-web-staging.azurewebsites.net" >> $GITHUB_OUTPUT
          else
            echo "url=https://tems-${ENV}-web.azurewebsites.net" >> $GITHUB_OUTPUT
          fi

      - name: Web smoke (Playwright)
        uses: ./shared/.github/actions/playwright-smoke
        env:
          B2C_TEST_USER_EMAIL: ${{ secrets.B2C_TEST_USER_EMAIL }}
          B2C_TEST_USER_PASSWORD: ${{ secrets.B2C_TEST_USER_PASSWORD }}
        with:
          base-url: ${{ steps.base.outputs.url }}
          artifact-name: web-playwright-${{ inputs.environment }}
          run-auth-smoke: 'true'

  route-traffic:
    name: Deploy to Production
    needs: [deploy-staging, verify-web, parity-gate]
    if: |
      always() &&
      (needs.verify-web.result == 'success') &&
      (inputs.environment != 'prod' || inputs['require-preprod-parity'] != 'true' || needs.parity-gate.result == 'success')
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    env:
      CALLER_WORKDIR: caller
    steps:
      - name: Resolve shared workflows ref
        id: wfref
        shell: bash
        working-directory: .
        run: |
          set -euo pipefail
          INPUT_REF="${{ inputs.shared_ref }}"
          if [ -n "$INPUT_REF" ]; then
            REF="$INPUT_REF"
          else
            REF="main"
            echo "### ⚠️ shared_ref not provided" >> "$GITHUB_STEP_SUMMARY"
            echo "Defaulting shared checkout to 'main'. For version-locked runs, pass inputs.shared_ref matching the @ref used in the caller." >> "$GITHUB_STEP_SUMMARY"
          fi
          echo "ref=$REF" >> "$GITHUB_OUTPUT"
          echo "Resolved shared workflows ref: $REF"

      - name: Checkout caller repo (no token persisted)
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          persist-credentials: false
          path: caller

      - name: Checkout shared workflows repo (no token persisted)
        uses: actions/checkout@v4
        with:
          repository: aexionsolutions/azure-devops-workflows
          ref: ${{ steps.wfref.outputs.ref }}
          fetch-depth: 1
          persist-credentials: false
          path: shared

      - name: Azure login (smart)
        uses: ./shared/.github/actions/azure-login-smart
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Download artifact (if provided)
        if: inputs['artifact-name'] != ''
        uses: actions/download-artifact@v6
        with:
          name: ${{ inputs['artifact-name'] }}
          path: _pkg

      - name: Resolve Resource Group (fallback if not provided)
        id: rgres
        if: inputs['resource-group'] == ''
        uses: ./shared/.github/actions/resolve-rg
        with:
          environment: ${{ inputs['environment'] }}
          default: ${{ secrets.AZURE_RESOURCE_GROUP }}
          dev: ${{ secrets.AZURE_RG_DEV }}
          uat: ${{ secrets.AZURE_RG_UAT }}
          preprod: ${{ secrets.AZURE_RG_PREPROD }}
          prod: ${{ secrets.AZURE_RG_PROD }}
          verify-exists: 'true'
          fail-on-missing: 'true'

      - name: Resolve package path and slot support
        id: resolve
        shell: bash
        env:
          PKG_INPUT: ${{ inputs['package'] }}
          ARTIFACT_NAME: ${{ inputs['artifact-name'] }}
          USE_SLOT_INPUT: ${{ needs.deploy-staging.outputs.use_slot }}
          RFP_IN: ${{ inputs['run-from-package'] }}
          RG_INPUT: ${{ inputs['resource-group'] }}
          RG_FALLBACK: ${{ steps.rgres.outputs.resource-group }}
          APP: ${{ inputs['app-name'] }}
          ENVIRONMENT: ${{ inputs['environment'] }}
        run: |
          set -euo pipefail
          RG="${RG_INPUT:-}"
          if [ -z "$RG" ]; then RG="${RG_FALLBACK:-}"; fi
          if [ -z "${RG:-}" ]; then
            echo "Missing input: resource-group and fallback resolution failed. Ensure a valid Resource Group is available." >&2
            exit 1
          fi
          if [ -z "${APP:-}" ]; then
            echo "Missing input: app-name. Ensure the caller passes 'app-name' to the reusable workflow." >&2
            exit 1
          fi
          ART="$ARTIFACT_NAME"
          if [ -n "$ART" ]; then
            PKG=$(find _pkg -maxdepth 1 -type f -name "*.zip" | head -n1 || true)
            if [ -z "$PKG" ]; then
              echo "Artifact $ART did not contain a .zip file" >&2; exit 1
            fi
          else
            PKG="$PKG_INPUT"
          fi
          if [ -z "$PKG" ]; then
            echo "No package provided (inputs.package) and no artifact-name specified; one is required." >&2
            exit 1
          fi
          echo "package=$PKG" >> $GITHUB_OUTPUT
          USE="$USE_SLOT_INPUT"
          echo "use_slot=$USE" >> $GITHUB_OUTPUT

          RFP=$(echo "${RFP_IN:-false}" | tr '[:upper:]' '[:lower:]')
          case "$RFP" in
            true|false) : ;;
            *) RFP=false ;;
          esac
          echo "run_from_package=$RFP" >> $GITHUB_OUTPUT
          echo "rg=$RG" >> $GITHUB_OUTPUT

      - name: Configure WEBSITE_RUN_FROM_PACKAGE
        shell: bash
        env:
          RG: ${{ steps.resolve.outputs.rg }}
          APP: ${{ inputs['app-name'] }}
          USE: ${{ steps.resolve.outputs.use_slot }}
          RFP: ${{ steps.resolve.outputs.run_from_package }}
        run: |
          set -euo pipefail
          if [ "$RFP" = "true" ]; then
            if [ "$USE" = "true" ]; then
              az webapp config appsettings set -g "$RG" -n "$APP" --slot staging --settings WEBSITE_RUN_FROM_PACKAGE=1
            else
              az webapp config appsettings set -g "$RG" -n "$APP" --settings WEBSITE_RUN_FROM_PACKAGE=1
            fi
          else
            if [ "$USE" = "true" ]; then
              az webapp config appsettings delete -g "$RG" -n "$APP" --slot staging --setting-names WEBSITE_RUN_FROM_PACKAGE || true
            else
              az webapp config appsettings delete -g "$RG" -n "$APP" --setting-names WEBSITE_RUN_FROM_PACKAGE || true
            fi
          fi

      - name: Set BUILD_VERSION app setting
        if: inputs['expect-version'] != ''
        shell: bash
        env:
          RG: ${{ steps.resolve.outputs.rg }}
          APP: ${{ inputs['app-name'] }}
          VERSION: ${{ inputs['expect-version'] }}
          ENV: ${{ inputs['environment'] }}
          USE: ${{ steps.resolve.outputs.use_slot }}
        run: |
          set -euo pipefail
          echo "Setting BUILD_VERSION=$VERSION on $APP..."
          if [ "$USE" = "true" ]; then
            az webapp config appsettings set -g "$RG" -n "$APP" --slot staging --settings BUILD_VERSION="$VERSION" ENV="$ENV"
            az webapp config appsettings set -g "$RG" -n "$APP" --settings BUILD_VERSION="$VERSION" ENV="$ENV"
          else
            az webapp config appsettings set -g "$RG" -n "$APP" --settings BUILD_VERSION="$VERSION" ENV="$ENV"
          fi

      - name: Swap slots + warmup production
        uses: ./shared/.github/actions/appservice-slot-deploy
        with:
          resource-group: ${{ steps.resolve.outputs.rg }}
          app-name: ${{ inputs['app-name'] }}
          package: ${{ steps.resolve.outputs.package }}
          use-slot: ${{ steps.resolve.outputs.use_slot }}
          warmup-url-staging: ${{ inputs['warmup-url-staging'] }}
          warmup-url-prod: ${{ inputs['warmup-url-prod'] }}
          skip-deploy: 'true'
          expect-version: ${{ inputs['expect-version'] }}
          version-url: ${{ inputs['version-url'] }}

  verify-summary:
    name: Verify Failure Summary
    needs: [verify-web]
    if: always() && (needs.verify-web.result == 'failure')
    runs-on: ubuntu-latest
    steps:
      - name: Write verify failure summary
        shell: bash
        env:
          URL_WEB: ${{ needs.verify-web.outputs.base_url }}
        run: |
          {
            echo "## ❌ Verification Failed"
            echo ""
            echo "**Web URL:** $URL_WEB"
            echo ""
            echo "See step logs above for details."
          } >> "$GITHUB_STEP_SUMMARY"
