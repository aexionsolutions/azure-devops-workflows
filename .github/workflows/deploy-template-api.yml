name: Template - Deploy API (App Service)

on:
  workflow_call:
    inputs:
      environment:
        required: true
        type: string
      app-name:
        required: true
        type: string
      resource-group:
        required: false
        type: string
        default: ''
      artifact-name:
        required: false
        type: string
        default: ''
      package:
        required: false
        type: string
        default: ''
      warmup-url-staging:
        required: false
        type: string
        default: ''
      warmup-url-prod:
        required: false
        type: string
        default: ''
      expect-version:
        required: false
        type: string
        default: ''
      version-url:
        required: false
        type: string
        default: ''
      run-from-package:
        required: false
        type: string
        default: 'true'
      verify-base-url:
        required: false
        type: string
        default: ''
      require-preprod-parity:
        required: false
        type: string
        default: 'false'
      preprod-version-url:
        required: false
        type: string
        default: ''
      swagger-enabled:
        required: false
        type: string
        default: 'true'
      api-protected-path:
        required: false
        type: string
        default: '/api/ping'
      b2c-kv-url:
        required: false
        type: string
        default: ''
      b2c-kv-secret-name:
        required: false
        type: string
        default: ''
      b2c-smoke-client-id:
        required: false
        type: string
        default: ''
    secrets:
      AZURE_CLIENT_ID:
        required: false
      AZURE_TENANT_ID:
        required: false
      AZURE_SUBSCRIPTION_ID:
        required: false
      AZURE_CREDENTIALS:
        required: false
      B2C_SMOKE_CLIENT_ID:
        required: false
      B2C_TEST_USER_EMAIL:
        required: false
      B2C_TEST_USER_PASSWORD:
        required: false

permissions:
  id-token: write
  contents: read

jobs:
  deploy-staging:
    name: Deploy to Staging
    uses: ./.github/workflows/appservice-slot-deploy.yml
    with:
      environment: ${{ inputs.environment }}
      resource-group: ${{ inputs.resource-group }}
      app-name: ${{ inputs.app-name }}
      artifact-name: ${{ inputs.artifact-name }}
      package: ${{ inputs.package }}
      use-slot: auto
      warmup-url-staging: ${{ inputs.warmup-url-staging }}
      warmup-url-prod: ${{ inputs.warmup-url-prod }}
      skip-swap: 'true'
      run-from-package: ${{ inputs['run-from-package'] }}
      display-name: Deploy to Staging
    secrets: inherit

  parity-gate:
    name: Preprod parity gate
    runs-on: ubuntu-latest
    if: inputs.environment == 'prod' && inputs['require-preprod-parity'] == 'true'
    steps:
      - name: Check preprod version matches expected
        shell: bash
        env:
          EXPECT: ${{ inputs['expect-version'] }}
          URL: ${{ inputs['preprod-version-url'] }}
        run: |
          set -euo pipefail
          if [ -z "${EXPECT:-}" ] || [ -z "${URL:-}" ]; then
            echo "Parity gate misconfigured: expect-version or preprod-version-url missing" >&2
            exit 1
          fi
          echo "Checking $URL contains version $EXPECT"
          BODY=$(curl -fsSL --max-time 20 "$URL" || true)
          if ! echo "$BODY" | grep -q "$EXPECT"; then
            echo "Preprod parity check failed: expected $EXPECT not found in response" >&2
            exit 1
          fi

  verify-api:
    name: Verify API Deployment
    needs: deploy-staging
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    env:
      CALLER_WORKDIR: caller

    defaults:
      run:
        working-directory: caller
    outputs:
      base_url: ${{ steps.base.outputs.url }}
    steps:
      - name: Resolve called workflow ref
        id: wfref
        shell: bash
        run: |
          set -e
          REF="${GITHUB_WORKFLOW_REF##*@}"
          if [ -z "$REF" ]; then REF="${GITHUB_SHA}"; fi
          echo "ref=$REF" >> "$GITHUB_OUTPUT"
          echo "Resolved workflow ref: $REF"

      - name: Checkout caller repo (no token persisted)
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          persist-credentials: false
          path: caller

      - name: Checkout shared workflows repo (no token persisted)
        uses: actions/checkout@v4
        with:
          repository: aexionsolutions/azure-devops-workflows
          ref: ${{ steps.wfref.outputs.ref }}
          fetch-depth: 1
          persist-credentials: false
          path: shared

      - name: Azure login (smart)
        uses: ./shared/.github/actions/azure-login-smart
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Decide base URL
        id: base
        shell: bash
        env:
          ENV: ${{ inputs.environment }}
          PROVIDED: ${{ inputs['verify-base-url'] }}
          USE_SLOT: ${{ needs.deploy-staging.outputs.use_slot }}
        run: |
          if [ -n "$PROVIDED" ]; then echo "url=$PROVIDED" >> $GITHUB_OUTPUT; exit 0; fi
          if [ "$USE_SLOT" = "true" ]; then
            echo "url=https://tems-${ENV}-api-staging.azurewebsites.net" >> $GITHUB_OUTPUT
          else
            echo "url=https://tems-${ENV}-api.azurewebsites.net" >> $GITHUB_OUTPUT
          fi

      - name: Resolve Resource Group (verify)
        id: rgres
        if: inputs['resource-group'] == ''
        uses: ./shared/.github/actions/resolve-rg
        with:
          environment: ${{ inputs.environment }}
          default: ${{ secrets.AZURE_RESOURCE_GROUP }}
          dev: ${{ secrets.AZURE_RG_DEV }}
          uat: ${{ secrets.AZURE_RG_UAT }}
          preprod: ${{ secrets.AZURE_RG_PREPROD }}
          prod: ${{ secrets.AZURE_RG_PROD }}
          verify-exists: 'true'
          fail-on-missing: 'true'

      - name: Read API auth settings (B2C)
        id: apisettings
        shell: bash
        env:
          RG_INPUT: ${{ inputs['resource-group'] }}
          RG_FALLBACK: ${{ steps.rgres.outputs.resource-group }}
          APP: ${{ inputs['app-name'] }}
          USE_SLOT: ${{ needs.deploy-staging.outputs.use_slot }}
        run: |
          set -euo pipefail
          RG="$RG_INPUT"; if [ -z "$RG" ]; then RG="$RG_FALLBACK"; fi
          if [ -z "$RG" ] || [ -z "${APP:-}" ]; then
            echo "Missing RG or app-name; cannot read app settings for token mint. Skipping settings read." >&2
            exit 0
          fi
          SLOT_ARGS=()
          if [ "$USE_SLOT" = "true" ]; then SLOT_ARGS=(--slot staging); fi
          JSON=$(az webapp config appsettings list -g "$RG" -n "$APP" ${SLOT_ARGS[@]} -o json || echo '[]')
          AUTH_B2C=$(echo "$JSON" | jq -r '.[] | select(.name=="Auth__B2C__Authority" or .name=="Auth:B2C:Authority") | .value' | head -n1)
          CLIENT_ID=$(echo "$JSON" | jq -r '.[] | select(.name=="Auth__ClientId" or .name=="Auth:ClientId") | .value' | head -n1)
          AUDIENCE=$(echo "$JSON" | jq -r '.[] | select(.name=="Auth__Audience" or .name=="Auth:Audience") | .value' | head -n1)
          echo "b2c_authority=$AUTH_B2C" >> $GITHUB_OUTPUT
          echo "client_id=$CLIENT_ID" >> $GITHUB_OUTPUT
          echo "audience=$AUDIENCE" >> $GITHUB_OUTPUT

      - name: Mint token for protected smoke (B2C ROPC for all environments)
        id: token
        shell: bash
        env:
          BASE: ${{ steps.base.outputs.url }}
          AUTH_B2C: ${{ steps.apisettings.outputs.b2c_authority }}
          CLIENT_ID_API: ${{ steps.apisettings.outputs.client_id }}
          AUDIENCE: ${{ steps.apisettings.outputs.audience }}
          SMOKE_CLIENT_ID: ${{ secrets.B2C_SMOKE_CLIENT_ID }}
          TEST_USER_EMAIL: ${{ secrets.B2C_TEST_USER_EMAIL }}
          TEST_USER_PASSWORD: ${{ secrets.B2C_TEST_USER_PASSWORD }}
          KV_URL: ${{ inputs['b2c-kv-url'] }}
          KV_SECRET_NAME: ${{ inputs['b2c-kv-secret-name'] }}
          ENV_NAME: ${{ inputs.environment }}
        run: |
          set -euo pipefail
          echo "ðŸ” Using B2C ROPC (password grant) for token minting..."
          if [ -z "$AUTH_B2C" ] || [ -z "$CLIENT_ID_API" ]; then
            echo "âŒ ERROR: B2C authority or API clientId missing from app settings." >&2
            echo "Ensure 'Auth:B2C:Authority' and 'Auth:ClientId' are configured on the API app settings." >&2
            exit 1
          fi
          TENANT_ID=$(echo "$AUTH_B2C" | sed -n 's|.*/\([0-9a-f-]*\)/v2\.0|\1|p')
          TENANT_SUBDOMAIN=$(echo "$AUTH_B2C" | sed -n 's|https://\([^.]*\)\.ciamlogin\.com.*|\1|p')
          if [ -z "$TENANT_ID" ] || [ -z "$TENANT_SUBDOMAIN" ]; then
            echo "Could not extract tenant ID or subdomain from authority: $AUTH_B2C" >&2
            exit 1
          fi
          TOKEN_URL="https://${TENANT_SUBDOMAIN}.ciamlogin.com/${TENANT_ID}/oauth2/v2.0/token"
          if [[ "$AUDIENCE" == api://* ]]; then
            SCOPE="${AUDIENCE}/Orders.ReadWrite openid offline_access"
          else
            SCOPE="api://${AUDIENCE}/Orders.ReadWrite openid offline_access"
          fi
          if [ -z "$SMOKE_CLIENT_ID" ]; then
            echo "âŒ ERROR: B2C_SMOKE_CLIENT_ID secret is required for ROPC authentication." >&2
            exit 1
          fi
          ROPC_CLIENT_ID="$SMOKE_CLIENT_ID"
          USER_EMAIL="$TEST_USER_EMAIL"
          USER_PASSWORD="$TEST_USER_PASSWORD"
          if [ -z "$USER_PASSWORD" ] && [ -n "${KV_URL:-}" ] && [ -n "${KV_SECRET_NAME:-}" ]; then
            echo "Attempting to fetch password from Key Vault..."
            USER_PASSWORD=$(az keyvault secret show --vault-url "$KV_URL" -n "$KV_SECRET_NAME" --query value -o tsv 2>/dev/null || true)
          fi
          if [ -z "$USER_EMAIL" ] || [ -z "$USER_PASSWORD" ]; then
            echo "âŒ ERROR: Test user credentials required for B2C ROPC authentication." >&2
            exit 1
          fi
          echo "Minting B2C token via ROPC (password grant) against $TOKEN_URL"
          ATTEMPTS=5
          SLEEP=2
          ACCESS_TOKEN=""
          for i in $(seq 1 $ATTEMPTS); do
            RESP=$(curl -sS -X POST \
              -H "Content-Type: application/x-www-form-urlencoded" \
              -d "grant_type=password" \
              -d "client_id=${ROPC_CLIENT_ID}" \
              -d "username=${USER_EMAIL}" \
              -d "password=${USER_PASSWORD}" \
              --data-urlencode "scope=${SCOPE}" \
              "$TOKEN_URL" || true)
            ACCESS_TOKEN=$(echo "$RESP" | jq -r '.access_token // empty')
            if [ -n "$ACCESS_TOKEN" ]; then
              break
            fi
            echo "Token mint attempt $i failed; retrying in ${SLEEP}s..." >&2
            sleep "$SLEEP"
            if [ $SLEEP -lt 16 ]; then SLEEP=$((SLEEP*2)); fi
          done
          if [ -z "$ACCESS_TOKEN" ]; then
            echo "Failed to mint access token after $ATTEMPTS attempts. Last response:" >&2
            echo "$RESP" >&2
            exit 1
          fi
          echo "token=***" >> $GITHUB_OUTPUT
          echo "::add-mask::$ACCESS_TOKEN"
          echo "B2C_ACCESS_TOKEN=$ACCESS_TOKEN" >> $GITHUB_ENV

      - name: Protected smoke token claims (debug)
        if: env.B2C_ACCESS_TOKEN != ''
        shell: bash
        env:
          ACCESS_TOKEN: ${{ env.B2C_ACCESS_TOKEN }}
        run: |
          set -euo pipefail
          if [ -z "${ACCESS_TOKEN:-}" ]; then
            echo "No token present to decode claims." >&2
            exit 1
          fi
          part2=$(echo "$ACCESS_TOKEN" | cut -d '.' -f2)
          rem=$(( ${#part2} % 4 ))
          if [ $rem -eq 2 ]; then part2+="=="; elif [ $rem -eq 3 ]; then part2+="="; fi
          json=$(echo "$part2" | tr '-_' '+/' | base64 -d 2>/dev/null || echo "{}")
          subset=$(echo "$json" | jq '{iss, aud, scp, roles, tfp, tid, azp, appid, sub, iat, nbf, exp} | with_entries(select(.value != null))')
          {
            echo "### Protected smoke token claims"
            echo '```json'
            echo "$subset"
            echo '```'
          } >> "$GITHUB_STEP_SUMMARY"

      - name: API health checks
        shell: bash
        run: |
          set -x
          curl -sS -i "${{ steps.base.outputs.url }}/healthz" || true
          curl -sS     "${{ steps.base.outputs.url }}/_meta" || true

      - name: API swagger smoke
        shell: bash
        env:
          SWAGGER_ENABLED: ${{ inputs['swagger-enabled'] }}
        run: |
          set -euo pipefail
          if [ "${SWAGGER_ENABLED,,}" != "true" ]; then
            echo "Swagger smoke skipped (SWAGGER_ENABLED!=true)"
            exit 0
          fi
          echo "Checking Swagger UI endpoint..."
          code=$(curl -s -o /dev/null -w "%{http_code}" "${{ steps.base.outputs.url }}/swagger/index.html" || true)
          echo "HTTP $code from /swagger/index.html"
          if [ "$code" -lt 200 ] || [ "$code" -ge 400 ]; then
            echo "Swagger UI not reachable (HTTP $code). If expected in this env, set SWAGGER_ENABLED=false at env/Org level." >&2
            exit 1
          fi

      - name: API protected smoke (auto)
        shell: bash
        env:
          TOKEN: ${{ env.B2C_ACCESS_TOKEN }}
          PATH_ONLY: ${{ inputs['api-protected-path'] }}
          BASE: ${{ steps.base.outputs.url }}
        run: |
          set -euo pipefail
          if [ -z "${TOKEN:-}" ]; then
            echo "API protected smoke cannot proceed: no token minted. Configure B2C_TEST_USER_EMAIL/PASSWORD secrets." >&2
            exit 1
          fi
          URL="${BASE%/}${PATH_ONLY}"
          echo "Protected smoke: GET $URL"
          code=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer $TOKEN" "$URL" || true)
          if [ "$code" -lt 200 ] || [ "$code" -ge 300 ]; then
            echo "First attempt HTTP $code; retrying in 3s..."
            sleep 3
            code=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer $TOKEN" "$URL" || true)
          fi
          echo "HTTP $code from protected endpoint"
          if [ "$code" -lt 200 ] || [ "$code" -ge 300 ]; then
            echo "Protected API smoke failed (HTTP $code)." >&2
            exit 1
          fi

  route-traffic:
    name: Deploy to Production
    needs: [deploy-staging, verify-api, parity-gate]
    if: |
      always() &&
      (needs.verify-api.result == 'success') &&
      (inputs.environment != 'prod' || inputs['require-preprod-parity'] != 'true' || needs.parity-gate.result == 'success')
    uses: ./.github/workflows/appservice-slot-deploy.yml
    with:
      environment: ${{ inputs.environment }}
      resource-group: ${{ inputs.resource-group }}
      app-name: ${{ inputs.app-name }}
      artifact-name: ${{ inputs.artifact-name }}
      package: ${{ inputs.package }}
      use-slot: auto
      warmup-url-staging: ${{ inputs.warmup-url-staging }}
      warmup-url-prod: ${{ inputs.warmup-url-prod }}
      skip-deploy: 'true'
      expect-version: ${{ inputs['expect-version'] }}
      version-url: ${{ inputs['version-url'] }}
      run-from-package: ${{ inputs['run-from-package'] }}
      display-name: Deploy to Production
    secrets: inherit

  verify-summary:
    name: Verify Failure Summary
    needs: [verify-api]
    if: always() && (needs.verify-api.result == 'failure')
    runs-on: ubuntu-latest
    steps:
      - name: Write verify failure summary
        shell: bash
        env:
          URL_API: ${{ needs.verify-api.outputs.base_url }}
        run: |
          {
            echo "## âŒ Verification Failed"
            echo ""
            echo "**API URL:** $URL_API"
            echo ""
            echo "See step logs above for details."
          } >> "$GITHUB_STEP_SUMMARY"
