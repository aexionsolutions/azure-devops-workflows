name: Azure Infrastructure Deploy

on:
  workflow_call:
    inputs:
      # Environment & Azure Settings
      environment:
        description: 'Environment to deploy (dev, uat, preprod, prod)'
        required: true
        type: string
      
      azure_location:
        description: 'Azure region (e.g., ukwest, uksouth, eastus)'
        required: true
        type: string
      
      resource_group:
        description: 'Resource group name (e.g., tems-dev-rg, ravenxpress-prod-rg)'
        required: true
        type: string
      
      # Bicep Configuration
      bicep_template_path:
        description: 'Path to main Bicep template (relative to repo root)'
        required: false
        type: string
        default: 'infra/main.bicep'
      
      deployment_name:
        description: 'Azure deployment name (defaults to "main")'
        required: false
        type: string
        default: 'main'
      
      # PostgreSQL Configuration
      postgres_server_name:
        description: 'PostgreSQL server name (auto-generated if not provided: <prefix>-<env>-pg)'
        required: false
        type: string
        default: ''
      
      postgres_admin_user:
        description: 'PostgreSQL admin username'
        required: false
        type: string
        default: 'pgadmin'
      
      manage_existing_postgres:
        description: 'Allow updates to existing Postgres server and ensure DB'
        required: false
        type: boolean
        default: false
      
      # Bicep Parameters (pass-through)
      name_prefix:
        description: 'Resource name prefix for Bicep template (e.g., tems-dev, ravenxpress-prod)'
        required: true
        type: string
      
      
      
      # Feature Flags
      enable_kv_rbac:
        description: 'Enable automatic Key Vault RBAC assignment for workflow and managed identities'
        required: false
        type: boolean
        default: true
      
      validate_secrets:
        description: 'Validate required secrets before deployment'
        required: false
        type: boolean
        default: true

      configure_app_services:
        description: 'Configure App Service settings with Key Vault references'
        required: false
        type: boolean
        default: true

      disable_easy_auth:
        description: 'Disable Easy Auth on API App Service'
        required: false
        type: boolean
        default: true
    
    secrets:
      AZURE_CLIENT_ID:
        description: 'Azure AD application (client) ID for OIDC authentication'
        required: true
      
      AZURE_TENANT_ID:
        description: 'Azure AD tenant ID'
        required: true
      
      AZURE_SUBSCRIPTION_ID:
        description: 'Azure subscription ID'
        required: true
      
      POSTGRES_ADMIN_PASSWORD:
        description: 'PostgreSQL administrator password'
        required: true

      AAD_B2C_AUTHORITY:
        description: 'Azure AD B2C authority URL (optional)'
        required: false

      AAD_B2C_CLIENT_ID:
        description: 'Azure AD B2C client ID (optional)'
        required: false

      AAD_B2C_API_SCOPE:
        description: 'Azure AD B2C API scope (optional)'
        required: false
      
      AZURE_CREDENTIALS:
        description: 'Azure service principal JSON (fallback authentication)'
        required: false

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    environment: ${{ inputs.environment }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Azure login (OIDC with fallback)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          enable-AzPSSession: false
          allow-no-subscriptions: false

      - name: Ensure latest Bicep CLI
        run: az bicep upgrade

      - name: Ensure PostgreSQL provider registered
        shell: bash
        run: |
          set -e
          STATE=$(az provider show -n Microsoft.DBforPostgreSQL --query registrationState -o tsv || echo "Unknown")
          echo "Microsoft.DBforPostgreSQL provider state: $STATE"
          if [ "$STATE" != "Registered" ] && [ "$STATE" != "Registering" ]; then
            echo "Attempting to register provider (best effort)..."
            az provider register -n Microsoft.DBforPostgreSQL --wait || echo "âš ï¸  Skipping provider register due to insufficient permissions."
          else
            echo "Provider already $STATE"
          fi

      - name: Ensure Application Insights provider registered
        shell: bash
        run: |
          set -e
          STATE=$(az provider show -n microsoft.operationalinsights --query registrationState -o tsv || echo "Unknown")
          echo "microsoft.operationalinsights provider state: $STATE"
          if [ "$STATE" != "Registered" ] && [ "$STATE" != "Registering" ]; then
            echo "Attempting to register provider (best effort)..."
            az provider register -n microsoft.operationalinsights --wait || echo "âš ï¸  Skipping provider register due to insufficient permissions."
          else
            echo "Provider already $STATE"
          fi

      - name: Ensure PostgreSQL flexible server CLI extension
        shell: bash
        run: |
          az extension add --name rdbms-flexible-server --upgrade -y || \
          az extension update --name rdbms-flexible-server -y || \
          true

      - name: Ensure resource group exists
        shell: bash
        run: |
          az group create \
            --name "${{ inputs.resource_group }}" \
            --location "${{ inputs.azure_location }}"

      - name: Validate required secrets
        if: inputs.validate_secrets == true
        shell: bash
        run: |
          set -e
          MISSING=""
          
          if [ -z "${{ secrets.POSTGRES_ADMIN_PASSWORD }}" ]; then
            echo "âŒ POSTGRES_ADMIN_PASSWORD secret is not set"
            MISSING="$MISSING POSTGRES_ADMIN_PASSWORD"
          fi
          
          if [ -n "$MISSING" ]; then
            echo ""
            echo "âŒ Missing required secrets:$MISSING"
            echo ""
            echo "Please configure secrets in GitHub:"
            echo "  Repository Settings â†’ Secrets and variables â†’ Actions â†’ Environment: '${{ inputs.environment }}'"
            exit 1
          fi
          
          echo "âœ… All required secrets are configured"

      - name: Resolve PostgreSQL server name
        id: pg
        shell: bash
        run: |
          if [ -n "${{ inputs.postgres_server_name }}" ]; then
            PG_NAME="${{ inputs.postgres_server_name }}"
          else
            PG_NAME="${{ inputs.name_prefix }}-pg"
          fi
          echo "server_name=$PG_NAME" >> $GITHUB_OUTPUT
          echo "PostgreSQL server name: $PG_NAME"

      - name: Check PostgreSQL server existence
        id: pg_exists
        shell: bash
        run: |
          set -e
          PG_NAME="${{ steps.pg.outputs.server_name }}"
          SUB_ID="${{ secrets.AZURE_SUBSCRIPTION_ID }}"
          
          if az resource show \
            -g "${{ inputs.resource_group }}" \
            -n "$PG_NAME" \
            --resource-type Microsoft.DBforPostgreSQL/flexibleServers \
            1>/dev/null 2>&1; then
            
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "PostgreSQL server $PG_NAME exists"
            
            # Get current state
            STATE=$(az rest --method get \
              --url "https://management.azure.com/subscriptions/$SUB_ID/resourceGroups/${{ inputs.resource_group }}/providers/Microsoft.DBforPostgreSQL/flexibleServers/$PG_NAME?api-version=2024-08-01" \
              --query properties.state -o tsv || echo "Unknown")
            echo "Current state: $STATE"
            
            # Determine if we need to start it
            if [ "${{ inputs.manage_existing_postgres }}" = "true" ]; then
              echo "needs_start=true" >> $GITHUB_OUTPUT
            else
              echo "needs_start=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "needs_start=false" >> $GITHUB_OUTPUT
            echo "PostgreSQL server $PG_NAME does not exist yet"
          fi

      - name: Start PostgreSQL server if needed (blocking)
        if: steps.pg_exists.outputs.exists == 'true' && steps.pg_exists.outputs.needs_start == 'true'
        shell: bash
        run: |
          set -e
          PG_NAME="${{ steps.pg.outputs.server_name }}"
          echo "Starting PostgreSQL server $PG_NAME..."
          
          az postgres flexible-server start \
            --resource-group "${{ inputs.resource_group }}" \
            --name "$PG_NAME" || echo "âš ï¸  Start command failed or server already started"
          
          echo "Waiting for server to be Ready..."
          MAX_ATTEMPTS=60
          SLEEP_SECONDS=10
          ATTEMPT=0
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            STATE=$(az postgres flexible-server show \
              --resource-group "${{ inputs.resource_group }}" \
              --name "$PG_NAME" \
              --query state -o tsv || echo "Unknown")
            
            echo "Attempt $((ATTEMPT+1))/$MAX_ATTEMPTS: State = $STATE"
            
            if [ "$STATE" = "Ready" ]; then
              echo "âœ… PostgreSQL server is Ready"
              exit 0
            fi
            
            ATTEMPT=$((ATTEMPT+1))
            sleep $SLEEP_SECONDS
          done
          
          echo "âš ï¸  PostgreSQL server did not reach Ready state within timeout"
          exit 1

      - name: Determine Bicep parameters for PostgreSQL
        id: bicep_params
        shell: bash
        run: |
          PG_EXISTS="${{ steps.pg_exists.outputs.exists }}"
          MANAGE_EXISTING="${{ inputs.manage_existing_postgres }}"
          
          # If managing existing, treat as non-existing in Bicep (allow updates)
          if [ "$PG_EXISTS" = "true" ] && [ "$MANAGE_EXISTING" = "true" ]; then
            echo "pg_existing=false" >> $GITHUB_OUTPUT
            echo "ensure_db=true" >> $GITHUB_OUTPUT
          elif [ "$PG_EXISTS" = "true" ]; then
            echo "pg_existing=true" >> $GITHUB_OUTPUT
            echo "ensure_db=false" >> $GITHUB_OUTPUT
          else
            echo "pg_existing=false" >> $GITHUB_OUTPUT
            echo "ensure_db=false" >> $GITHUB_OUTPUT
          fi

      - name: Deploy Bicep template
        id: deploy
        shell: bash
        env:
          PG_ADMIN_PASSWORD: ${{ secrets.POSTGRES_ADMIN_PASSWORD }}
          AAD_AUTHORITY: ${{ secrets.AAD_B2C_AUTHORITY }}
          AAD_CLIENT_ID: ${{ secrets.AAD_B2C_CLIENT_ID }}
          AAD_API_SCOPE: ${{ secrets.AAD_B2C_API_SCOPE }}
        run: |
          set -e
          az deployment group create \
            --resource-group "${{ inputs.resource_group }}" \
            --name "${{ inputs.deployment_name }}" \
            --template-file "${{ inputs.bicep_template_path }}" \
            --parameters namePrefix="${{ inputs.name_prefix }}" \
                         pgAdminUser="${{ inputs.postgres_admin_user }}" \
                         pgAdminPassword="$PG_ADMIN_PASSWORD" \
                         pgExisting="${{ steps.bicep_params.outputs.pg_existing }}" \
                         ensureDbOnExisting="${{ steps.bicep_params.outputs.ensure_db }}" \
                         aadAuthority="$AAD_AUTHORITY" \
                         aadClientId="$AAD_CLIENT_ID" \
                         aadApiScope="$AAD_API_SCOPE"

      - name: Show deployment error details (if failed)
        if: failure()
        shell: bash
        run: |
          echo "== Deployment error details =="
          az deployment group show \
            --resource-group "${{ inputs.resource_group }}" \
            --name "${{ inputs.deployment_name }}" \
            --query properties.error -o jsonc || true
          
          echo ""
          echo "== Failed operations (last 50) =="
          az deployment operation group list \
            --resource-group "${{ inputs.resource_group }}" \
            --name "${{ inputs.deployment_name }}" \
            --query "[?properties.provisioningState=='Failed'].{Operation:properties.targetResource.resourceType, Name:properties.targetResource.resourceName, Error:properties.statusMessage.error}" \
            -o jsonc || true

      - name: Get deployment outputs
        id: outputs
        shell: bash
        run: |
          OUTPUTS=$(az deployment group show \
            --resource-group "${{ inputs.resource_group }}" \
            --name "${{ inputs.deployment_name }}" \
            --query properties.outputs -o json)
          
          echo "outputs<<EOF" >> $GITHUB_OUTPUT; echo "$OUTPUTS" >> $GITHUB_OUTPUT; echo "EOF" >> $GITHUB_OUTPUT
          echo "Deployment outputs:"
          echo "$OUTPUTS" | jq .
      - name: Capture outputs (names only)
        id: out
        shell: bash
        run: |
          set -e
          OUTPUTS=$(az deployment group show \
            --resource-group "${{ inputs.resource_group }}" \
            --name "${{ inputs.deployment_name }}" \
            --query properties.outputs -o json)
          
          echo "KV_NAME=$(echo "$OUTPUTS" | jq -r '.kvName.value')" >> $GITHUB_OUTPUT
          echo "KV_URI=$(echo "$OUTPUTS" | jq -r '.kvUri.value')" >> $GITHUB_OUTPUT
          echo "API_NAME=$(echo "$OUTPUTS" | jq -r '.apiName.value')" >> $GITHUB_OUTPUT
          echo "WEB_NAME=$(echo "$OUTPUTS" | jq -r '.webName.value')" >> $GITHUB_OUTPUT
          echo "APP_INSIGHTS_CONN=$(echo "$OUTPUTS" | jq -r '.appInsightsConnectionString.value')" >> $GITHUB_OUTPUT
          echo "REDIS_HOST=$(echo "$OUTPUTS" | jq -r '.redisHost.value')" >> $GITHUB_OUTPUT
          echo "REDIS_NAME=$(echo "$OUTPUTS" | jq -r '.redisName.value')" >> $GITHUB_OUTPUT
          echo "SB_NAMESPACE=$(echo "$OUTPUTS" | jq -r '.sbNamespace.value')" >> $GITHUB_OUTPUT
          echo "STG_NAME=$(echo "$OUTPUTS" | jq -r '.storageAccountName.value')" >> $GITHUB_OUTPUT
          echo "PG_FQDN=$(echo "$OUTPUTS" | jq -r '.pgFqdn.value')" >> $GITHUB_OUTPUT
          echo "PG_DB=$(echo "$OUTPUTS" | jq -r '.pgDatabase.value')" >> $GITHUB_OUTPUT



      - name: Setup Key Vault RBAC (if enabled)
        if: inputs.enable_kv_rbac == true
        shell: bash
        run: |
          set -e
          
          # Get Key Vault name from deployment outputs
          KV_NAME=$(az deployment group show \
            --resource-group "${{ inputs.resource_group }}" \
            --name "${{ inputs.deployment_name }}" \
            --query "properties.outputs.keyVaultName.value" -o tsv || echo "")
          
          if [ -z "$KV_NAME" ]; then
            echo "âš ï¸  Key Vault name not found in deployment outputs, skipping RBAC setup"
            exit 0
          fi
          
          echo "Setting up Key Vault RBAC for: $KV_NAME"
          
          # Get workflow identity principal ID
          WORKFLOW_PRINCIPAL_ID=$(az ad sp show --id "${{ secrets.AZURE_CLIENT_ID }}" --query id -o tsv)
          
          # Assign Key Vault Secrets Officer to workflow identity
          echo "Assigning Key Vault Secrets Officer to workflow identity..."
          az role assignment create \
            --assignee-object-id "$WORKFLOW_PRINCIPAL_ID" \
            --assignee-principal-type ServicePrincipal \
            --role "Key Vault Secrets Officer" \
            --scope "/subscriptions/${{ secrets.AZURE_SUBSCRIPTION_ID }}/resourceGroups/${{ inputs.resource_group }}/providers/Microsoft.KeyVault/vaults/$KV_NAME" \
            2>&1 || echo "âš ï¸  Role assignment may already exist or insufficient permissions"
          
          # Get API managed identity principal ID (if exists)
          API_MI_NAME="${{ inputs.name_prefix }}-api-mi"
          API_MI_ID=$(az identity show \
            --resource-group "${{ inputs.resource_group }}" \
            --name "$API_MI_NAME" \
            --query principalId -o tsv 2>/dev/null || echo "")
          
          if [ -n "$API_MI_ID" ]; then
            echo "Assigning Key Vault Secrets User to API managed identity..."
            az role assignment create \
              --assignee-object-id "$API_MI_ID" \
              --assignee-principal-type ServicePrincipal \
              --role "Key Vault Secrets User" \
              --scope "/subscriptions/${{ secrets.AZURE_SUBSCRIPTION_ID }}/resourceGroups/${{ inputs.resource_group }}/providers/Microsoft.KeyVault/vaults/$KV_NAME" \
              2>&1 || echo "âš ï¸  Role assignment may already exist or insufficient permissions"
          fi
          
          echo "âœ… Key Vault RBAC setup completed"
      - name: Ensure system-assigned identities on apps (idempotent)
        if: inputs.configure_app_services == true
        shell: bash
        env:
          API_NAME: ${{ steps.out.outputs.API_NAME }}
          WEB_NAME: ${{ steps.out.outputs.WEB_NAME }}
        run: |
          set -e
          echo "Enabling system-assigned managed identity on API and Web apps..."
          az webapp identity assign \
            -g "${{ inputs.resource_group }}" \
            -n "$API_NAME" \
            --output none || true
          az webapp identity assign \
            -g "${{ inputs.resource_group }}" \
            -n "$WEB_NAME" \
            --output none || true
          echo " Managed identities enabled"

      - name: Ensure KV access for API identity (idempotent)
        if: inputs.configure_app_services == true
        shell: bash
        env:
          KV_NAME: ${{ steps.out.outputs.KV_NAME }}
          API_NAME: ${{ steps.out.outputs.API_NAME }}
        run: |
          set -e
          KV_ID=$(az keyvault show \
            -n "$KV_NAME" \
            -g "${{ inputs.resource_group }}" \
            --query id -o tsv)

          API_PID=$(az webapp show \
            -n "$API_NAME" \
            -g "${{ inputs.resource_group }}" \
            --query identity.principalId -o tsv)

          ROLE="4633458b-17de-408a-b874-0445c86b69e6" # Key Vault Secrets User

          # Check if assignment already exists
          existing=$(az role assignment list \
            --assignee "$API_PID" \
            --role "$ROLE" \
            --scope "$KV_ID" \
            --query "length(@)" -o tsv 2>/dev/null || echo "0")

          if [ "$existing" -eq 0 ]; then
            echo "Granting Key Vault Secrets User role to API managed identity..."
            if az role assignment create \
              --assignee "$API_PID" \
              --role "$ROLE" \
              --scope "$KV_ID" \
              --only-show-errors 2>/dev/null; then
              echo " Role assignment created"
            else
              echo "  Failed to create role assignment (may need manual assignment)"
            fi
          else
            echo " Key Vault Secrets User already assigned to API"
          fi

          # Wait for RBAC propagation
          echo "Waiting for RBAC propagation (up to 90s)..."
          for i in 1 2 3 4 5 6 7 8 9; do
            sleep 10
            if az keyvault secret list --vault-name "$KV_NAME" --maxresults 1 >/dev/null 2>&1; then
              echo " Key Vault accessible"
              break
            fi
          done

      - name: Compute connection strings and store in KV
        if: inputs.configure_app_services == true
        shell: bash
        env:
          KV_NAME: ${{ steps.out.outputs.KV_NAME }}
        run: |
          set -e
          echo "Validating connection string secrets created by Bicep..."

          # List of required secrets
          REQUIRED_SECRETS=(
            "RedisConnectionString"
            "ServiceBusConnectionString"
            "StorageConnectionString"
            "PostgresConnectionString"
          )

          # Verify all secrets exist
          for secret in "${REQUIRED_SECRETS[@]}"; do
            if az keyvault secret show --vault-name "$KV_NAME" -n "$secret" --query name -o tsv &>/dev/null; then
              echo "   $secret exists"
            else
              echo "   ERROR: $secret not found in Key Vault"
              echo "  Check Bicep modules in infra/*/azure/modules/"
              exit 1
            fi
          done

          # Validate PostgreSQL connection string format
          PG_CONN=$(az keyvault secret show --vault-name "$KV_NAME" -n "PostgresConnectionString" --query value -o tsv)
          PG_CONN_LENGTH=${#PG_CONN}

          if [ "$PG_CONN_LENGTH" -lt 80 ]; then
            echo " PostgresConnectionString too short (< 80 chars)"
            exit 1
          fi

          if [[ ! "$PG_CONN" =~ Host=.*\.postgres\.database\.azure\.com.*Database=.*Username=.*Password=.*SslMode=.*TrustServerCertificate=.* ]]; then
            echo " PostgresConnectionString format validation failed"
            exit 1
          fi

          echo " All connection strings validated"


      - name: Set App Service settings
        if: inputs.configure_app_services == true
        shell: bash
        env:
          KV_URI: ${{ steps.out.outputs.KV_URI }}
          APP_INSIGHTS_CONN: ${{ steps.out.outputs.APP_INSIGHTS_CONN }}
          API_NAME: ${{ steps.out.outputs.API_NAME }}
          WEB_NAME: ${{ steps.out.outputs.WEB_NAME }}
          AAD_AUTHORITY: ${{ secrets.AAD_B2C_AUTHORITY }}
          AAD_CLIENT_ID: ${{ secrets.AAD_B2C_CLIENT_ID }}
          AAD_API_SCOPE: ${{ secrets.AAD_B2C_API_SCOPE }}
        run: |
          set -e
          
          echo "Configuring App Service settings with Key Vault references..."
          
          # Set API app settings with Key Vault references
          API_SETTINGS=(
            "ASPNETCORE_ENVIRONMENT=Production"
            "APPLICATIONINSIGHTS_CONNECTION_STRING=$APP_INSIGHTS_CONN"
            "Storage__ConnectionString=@Microsoft.KeyVault(SecretUri=${KV_URI}secrets/StorageConnectionString)"
            "Redis__ConnectionString=@Microsoft.KeyVault(SecretUri=${KV_URI}secrets/RedisConnectionString)"
            "ServiceBus__ConnectionString=@Microsoft.KeyVault(SecretUri=${KV_URI}secrets/ServiceBusConnectionString)"
            "ConnectionStrings__Postgres=@Microsoft.KeyVault(SecretUri=${KV_URI}secrets/PostgresConnectionString)"
            "Auth:Mode=b2c"
          )
          
          # Add AAD B2C settings if provided
          if [ -n "$AAD_CLIENT_ID" ]; then 
            API_SETTINGS+=("Auth:ClientId=$AAD_CLIENT_ID")
          fi
          if [ -n "$AAD_AUTHORITY" ]; then 
            API_SETTINGS+=("Auth:B2C:Authority=$AAD_AUTHORITY")
          fi
          if [ -n "$AAD_API_SCOPE" ]; then
            # Extract audience from scope (api://GUID/Scope  api://GUID)
            AUDIENCE_URI=$(echo "$AAD_API_SCOPE" | sed 's|^\(api://[^/]*\)/.*|\1|; t; s|^\([^/]*\)/.*|\1|')
            API_SETTINGS+=("Auth:Audience=$AUDIENCE_URI")
          fi
          
          az webapp config appsettings set \
            -g "${{ inputs.resource_group }}" \
            -n "$API_NAME" \
            --settings "${API_SETTINGS[@]}" \
            --output none
          
          echo " API app settings configured"
          
          # Set Web app settings
          WEB_SETTINGS="APPLICATIONINSIGHTS_CONNECTION_STRING=$APP_INSIGHTS_CONN API_BASE=https://${API_NAME}.azurewebsites.net NEXT_PUBLIC_API_BASE=https://${API_NAME}.azurewebsites.net WEBSITE_NODE_DEFAULT_VERSION=~20"
          
          # Add AAD settings if provided (both runtime and build-time vars)
          if [ -n "$AAD_AUTHORITY" ]; then
            WEB_SETTINGS="$WEB_SETTINGS AAD_AUTHORITY=$AAD_AUTHORITY NEXT_PUBLIC_AAD_AUTHORITY=$AAD_AUTHORITY AAD_CLIENT_ID=$AAD_CLIENT_ID NEXT_PUBLIC_AAD_CLIENT_ID=$AAD_CLIENT_ID AAD_API_SCOPE=$AAD_API_SCOPE NEXT_PUBLIC_AAD_API_SCOPE=$AAD_API_SCOPE"
          fi
          
          az webapp config appsettings set \
            -g "${{ inputs.resource_group }}" \
            -n "$WEB_NAME" \
            --settings $WEB_SETTINGS \
            --output none
          
          echo " Web app settings configured"

      - name: Ensure Easy Auth disabled on API (idempotent)
        if: inputs.disable_easy_auth == true
        shell: bash
        env:
          API_NAME: ${{ steps.out.outputs.API_NAME }}
        run: |
          echo "Disabling App Service Authentication (Easy Auth) on $API_NAME"
          az webapp auth set \
            -g "${{ inputs.resource_group }}" \
            -n "$API_NAME" \
            --enabled false \
            --output none || true
          echo " Easy Auth disabled"



      - name: Deployment Summary
        shell: bash
        run: |
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Resource Group**: ${{ inputs.resource_group }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Location**: ${{ inputs.azure_location }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployment Name**: ${{ inputs.deployment_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **PostgreSQL Server**: ${{ steps.pg.outputs.server_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Infrastructure deployment completed successfully" >> $GITHUB_STEP_SUMMARY
